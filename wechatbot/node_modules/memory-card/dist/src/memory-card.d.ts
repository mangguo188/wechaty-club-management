import { AsyncMapLike } from 'async-map-like';
import { StorageBackend, StorageBackendOptions } from './storage/mod';
import { MemoryCardPayload } from './types';
export declare const NAMESPACE_MULTIPLEX_SEPRATOR = "\r";
export declare const NAMESPACE_KEY_SEPRATOR = "\n";
export interface MemoryCardOptions {
    name?: string;
    storageOptions?: StorageBackendOptions;
    multiplex?: {
        parent: MemoryCard;
        name: string;
    };
}
export interface MemoryCardJsonObject {
    payload: MemoryCardPayload;
    options: MemoryCardOptions;
}
export declare class MemoryCard implements AsyncMapLike<any, any> {
    /**
     *
     *
     * Static
     *
     *
     */
    static VERSION: string;
    fromJSON(textOrObj: string | MemoryCardJsonObject): MemoryCard;
    protected static multiplex<T extends typeof MemoryCard>(this: T, memory: MemoryCard, name: string): T['prototype'];
    /**
     *
     *
     * Instance
     *
     *
     */
    name?: string;
    protected parent?: MemoryCard;
    protected payload?: MemoryCardPayload;
    protected storage?: StorageBackend;
    protected multiplexNameList: string[];
    private options?;
    constructor(options?: string | MemoryCardOptions);
    toString(): string;
    version(): string;
    private getStorage;
    load(): Promise<void>;
    save(): Promise<void>;
    /**
     *
     * Multiplexing related functions START
     *
     */
    protected isMultiplexKey(key: string): boolean;
    protected multiplexNamespace(): string;
    protected resolveKey(name: string): string;
    isMultiplex(): boolean;
    protected multiplexPath(): string;
    /**
     * @deprecated use multiplex() instead
     * @hidden
     */
    sub(name: string): this;
    multiplex(name: string): this;
    /**
     *
     * Multiplexing related functions END
     *
     */
    destroy(): Promise<void>;
    /**
     *
     * ES6 Map API (Async Version)
     *
     * BEGIN
     *
     */
    /**
     * size
     */
    get size(): Promise<number>;
    get<T = any>(name: string): Promise<undefined | T>;
    set<T = any>(name: string, data: T): Promise<this>;
    [Symbol.asyncIterator]<T = any>(): AsyncIterableIterator<[string, T]>;
    entries<T = any>(): AsyncIterableIterator<[string, T]>;
    clear(): Promise<void>;
    delete(name: string): Promise<boolean>;
    has(key: string): Promise<boolean>;
    keys(): AsyncIterableIterator<string>;
    values<T = any>(): AsyncIterableIterator<T>;
    forEach<T>(callbackfn: (value: T, key: string, map: any) => void, thisArg?: any): Promise<void>;
}
export default MemoryCard;
//# sourceMappingURL=memory-card.d.ts.map