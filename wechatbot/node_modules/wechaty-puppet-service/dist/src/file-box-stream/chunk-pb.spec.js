#!/usr/bin/env ts-node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = __importDefault(require("tstest"));
const stream_1 = require("stream");
const wechaty_puppet_1 = require("wechaty-puppet");
const wechaty_grpc_1 = require("wechaty-grpc");
const file_box_chunk_1 = require("./file-box-chunk");
const chunk_pb_1 = require("./chunk-pb");
tstest_1.default('packFileBoxChunk()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = wechaty_puppet_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await file_box_chunk_1.packFileBoxToChunk(fileBox);
    const pbStream = await chunk_pb_1.packFileBoxChunkToPb(wechaty_grpc_1.MessageFileStreamResponse)(chunkStream);
    let name = '';
    let buffer = '';
    pbStream.on('data', (data) => {
        if (data.hasFileBoxChunk()) {
            const fileBoxChunk = data.getFileBoxChunk();
            if (fileBoxChunk.hasData()) {
                buffer += fileBoxChunk.getData();
            }
            else if (fileBoxChunk.hasName()) {
                name = fileBoxChunk.getName();
            }
        }
    });
    await new Promise(resolve => chunkStream.on('end', resolve));
    t.equal(name, FILE_BOX_NAME, 'should get file box name');
    t.equal(buffer, FILE_BOX_DATA, 'should get file box data');
});
tstest_1.default('unpackFileBoxChunkFromPb()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = wechaty_puppet_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await file_box_chunk_1.packFileBoxToChunk(fileBox);
    const request = new wechaty_grpc_1.MessageSendFileStreamRequest();
    const packedStream = new stream_1.PassThrough({ objectMode: true });
    chunkStream.on('data', (data) => {
        request.setFileBoxChunk(data);
        packedStream.write(request);
    }).on('end', () => {
        packedStream.end();
    });
    const outputChunkStream = chunk_pb_1.unpackFileBoxChunkFromPb(packedStream);
    const outputFileBox = await file_box_chunk_1.unpackFileBoxFromChunk(outputChunkStream);
    t.equal((await outputFileBox.toBuffer()).toString(), FILE_BOX_DATA, 'should get file box data');
});
tstest_1.default('packFileBoxChunk() <-> unpackFileBoxChunkFromPb()', async (t) => {
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = wechaty_puppet_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await file_box_chunk_1.packFileBoxToChunk(fileBox);
    const packedStream = chunk_pb_1.packFileBoxChunkToPb(wechaty_grpc_1.MessageFileStreamResponse)(chunkStream);
    const unpackedStream = chunk_pb_1.unpackFileBoxChunkFromPb(packedStream);
    const restoredBox = await file_box_chunk_1.unpackFileBoxFromChunk(unpackedStream);
    t.equal(fileBox.name, restoredBox.name, 'should be same name');
    const EXPECTED_BASE64 = await fileBox.toBase64();
    const actualBase64 = await restoredBox.toBase64();
    t.equal(EXPECTED_BASE64, actualBase64, 'should be same content');
});
tstest_1.default('packFileBoxChunk(): should not throw if no read on the stream', async (t) => {
    t.plan(1);
    const stream = await getTestChunkStream({});
    let outStream;
    try {
        outStream = chunk_pb_1.packFileBoxChunkToPb(wechaty_grpc_1.MessageFileStreamResponse)(stream);
    }
    catch (e) {
        t.assert(e.message);
        return;
    }
    outStream.on('error', _ => { });
    t.pass();
});
tstest_1.default('packFileBoxChunk(): should emit error in the output stream', async (t) => {
    t.plan(1);
    const errorMessage = 'test emit error';
    const stream = await getTestChunkStream({ errorMessage });
    const outStream = chunk_pb_1.packFileBoxChunkToPb(wechaty_grpc_1.MessageFileStreamResponse)(stream);
    outStream.on('error', e => {
        t.equal(e.message, errorMessage);
    });
    await new Promise(resolve => outStream.on('end', resolve));
});
tstest_1.default('unpackFileBoxChunkFromPb(): should not throw if no read on the stream', async (t) => {
    t.plan(1);
    const stream = await getTestPackedStream({});
    let outStream;
    try {
        outStream = chunk_pb_1.unpackFileBoxChunkFromPb(stream);
        t.pass('should no rejection');
    }
    catch (e) {
        t.fail(e.message);
        return;
    }
    outStream.on('error', _ => { });
});
tstest_1.default('unpackFileBoxChunkFromPb(): should emit error in the output stream', async (t) => {
    const errorMessage = 'test emit error';
    const stream = await getTestPackedStream({ errorMessage });
    const outStream = chunk_pb_1.packFileBoxChunkToPb(wechaty_grpc_1.MessageFileStreamResponse)(stream);
    try {
        await new Promise((resolve, reject) => {
            outStream.on('error', reject);
            outStream.on('end', resolve);
        });
        t.fail('should reject the promise');
    }
    catch (e) {
        t.equal(e.message, errorMessage, 'should get the expected rejection error message');
    }
});
const getTestChunkStream = async (options) => {
    const { errorMessage } = options;
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = wechaty_puppet_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await file_box_chunk_1.packFileBoxToChunk(fileBox);
    setImmediate(() => {
        chunkStream.emit('error', new Error(errorMessage));
    });
    return chunkStream;
};
const getTestPackedStream = async (options) => {
    const { errorMessage } = options;
    const FILE_BOX_DATA = 'test';
    const FILE_BOX_NAME = 'test.dat';
    const fileBox = wechaty_puppet_1.FileBox.fromBuffer(Buffer.from(FILE_BOX_DATA), FILE_BOX_NAME);
    const chunkStream = await file_box_chunk_1.packFileBoxToChunk(fileBox);
    const packedStream = new stream_1.PassThrough({ objectMode: true });
    chunkStream.on('data', d => {
        const packedChunk = new wechaty_grpc_1.MessageFileStreamResponse();
        packedChunk.setFileBoxChunk(d);
        packedStream.write(packedChunk);
    }).on('error', e => {
        packedStream.emit('error', e);
    });
    setImmediate(() => {
        chunkStream.emit('error', new Error(errorMessage));
    });
    return packedStream;
};
//# sourceMappingURL=chunk-pb.spec.js.map