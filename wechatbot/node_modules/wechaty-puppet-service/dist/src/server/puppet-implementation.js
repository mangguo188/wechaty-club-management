"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.puppetImplementation = void 0;
const wechaty_grpc_1 = require("wechaty-grpc");
const wechaty_puppet_1 = require("wechaty-puppet");
const mod_1 = require("../file-box-stream/mod");
const config_1 = require("../config");
const grpc_error_1 = require("./grpc-error");
const event_stream_manager_1 = require("./event-stream-manager");
const serialize_file_box_1 = require("./serialize-file-box");
/**
 * Implements the SayHello RPC method.
 */
function puppetImplementation(puppet) {
    /**
     * Save scan payload to send it to the puppet-service right after connected (if needed)
     *
     * TODO: clean the listeners if necessary
     */
    let scanPayload;
    let readyPayload;
    let readyTimeout;
    puppet
        .on('scan', payload => { scanPayload = payload; })
        .on('ready', payload => { readyPayload = payload; })
        .on('logout', _ => {
        readyPayload = undefined;
        if (readyTimeout) {
            clearTimeout(readyTimeout);
        }
    })
        .on('login', _ => {
        scanPayload = undefined;
        readyTimeout = setTimeout(() => {
            readyPayload && eventStreamManager.grpcEmit(wechaty_grpc_1.EventType.EVENT_TYPE_READY, readyPayload);
        }, 5 * 1000);
    });
    const eventStreamManager = new event_stream_manager_1.EventStreamManager(puppet);
    const puppetServerImpl = {
        contactAlias: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactAlias()');
            const id = call.request.getId();
            /**
             * Set
             */
            {
                const aliasWrapper = call.request.getAlias();
                if (aliasWrapper) {
                    try {
                        await puppet.contactAlias(id, aliasWrapper.getValue());
                        return callback(null, new wechaty_grpc_1.ContactAliasResponse());
                    }
                    catch (e) {
                        return grpc_error_1.grpcError('contactAlias', e, callback);
                    }
                }
            }
            /**
             * Get
             */
            try {
                const alias = await puppet.contactAlias(id);
                const aliasWrapper = new wechaty_grpc_1.StringValue();
                aliasWrapper.setValue(alias);
                const response = new wechaty_grpc_1.ContactAliasResponse();
                response.setAlias(aliasWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAlias', e, callback);
            }
        },
        contactAvatar: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactAvatar()');
            const id = call.request.getId();
            /**
             * Set
             */
            try {
                const fileBoxWrapper = call.request.getFilebox();
                if (fileBoxWrapper) {
                    const fileBox = wechaty_puppet_1.FileBox.fromJSON(fileBoxWrapper.getValue());
                    await puppet.contactAvatar(id, fileBox);
                    return callback(null, new wechaty_grpc_1.ContactAvatarResponse());
                }
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAvatar', e, callback);
            }
            /**
             * Get
             */
            try {
                const fileBox = await puppet.contactAvatar(id);
                const fileBoxWrapper = new wechaty_grpc_1.StringValue();
                fileBoxWrapper.setValue(JSON.stringify(fileBox));
                const response = new wechaty_grpc_1.ContactAvatarResponse();
                response.setFilebox(fileBoxWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactAvatar', e, callback);
            }
        },
        contactCorporationRemark: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactCorporationRemark()');
            const contactId = call.request.getContactId();
            let corporationRemark = null;
            try {
                const corporationRemarkWrapper = call.request.getCorporationRemark();
                if (corporationRemarkWrapper) {
                    corporationRemark = corporationRemarkWrapper.getValue();
                }
                await puppet.contactCorporationRemark(contactId, corporationRemark);
                return callback(null, new wechaty_grpc_1.ContactCorporationRemarkResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactCorporationRemark', e, callback);
            }
        },
        contactDescription: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactDescription()');
            const contactId = call.request.getContactId();
            let description = null;
            try {
                const descriptionWrapper = call.request.getDescription();
                if (descriptionWrapper) {
                    description = descriptionWrapper.getValue();
                }
                await puppet.contactDescription(contactId, description);
                return callback(null, new wechaty_grpc_1.ContactDescriptionResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactDescription', e, callback);
            }
        },
        contactList: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactList()');
            void call; // empty request
            try {
                const idList = await puppet.contactList();
                const response = new wechaty_grpc_1.ContactListResponse();
                response.setIdsList(idList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactList', e, callback);
            }
        },
        contactPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactPayload()');
            const id = call.request.getId();
            try {
                const payload = await puppet.contactPayload(id);
                const response = new wechaty_grpc_1.ContactPayloadResponse();
                response.setAddress(payload.address || '');
                response.setAlias(payload.alias || '');
                response.setAvatar(payload.avatar);
                response.setCity(payload.city || '');
                response.setFriend(payload.friend || false);
                response.setGender(payload.gender);
                response.setId(payload.id);
                response.setName(payload.name);
                response.setProvince(payload.province || '');
                response.setSignature(payload.signature || '');
                response.setStar(payload.star || false);
                response.setType(payload.type);
                response.setWeixin(payload.weixin || '');
                response.setPhoneList(payload.phone);
                response.setCoworker(payload.coworker || false);
                response.setCorporation(payload.corporation || '');
                response.setTitle(payload.title || '');
                response.setDescription(payload.description || '');
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactPayload', e, callback);
            }
        },
        contactPhone: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactPhone()');
            try {
                const contactId = call.request.getContactId();
                const phoneList = call.request.getPhoneListList();
                await puppet.contactPhone(contactId, phoneList);
                return callback(null, new wechaty_grpc_1.ContactPhoneResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactPhone', e, callback);
            }
        },
        contactSelfName: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfName()');
            try {
                const name = call.request.getName();
                await puppet.contactSelfName(name);
                return callback(null, new wechaty_grpc_1.ContactSelfNameResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfName', e, callback);
            }
        },
        contactSelfQRCode: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfName()');
            void call;
            try {
                const qrcode = await puppet.contactSelfQRCode();
                const response = new wechaty_grpc_1.ContactSelfQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfQRCode', e, callback);
            }
        },
        contactSelfSignature: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'contactSelfSignature()');
            try {
                const signature = call.request.getSignature();
                await puppet.contactSelfSignature(signature);
                return callback(null, new wechaty_grpc_1.ContactSelfSignatureResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('contactSelfSignature', e, callback);
            }
        },
        ding: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'ding()');
            try {
                const data = call.request.getData();
                await puppet.ding(data);
                return callback(null, new wechaty_grpc_1.DingResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('ding', e, callback);
            }
        },
        dirtyPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'dirtyPayload()');
            try {
                const id = call.request.getId();
                const type = call.request.getType();
                await puppet.dirtyPayload(type, id);
                return callback(null, new wechaty_grpc_1.DirtyPayloadResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('dirtyPayload', e, callback);
            }
        },
        /**
         *
         * Bridge Event Emitter Events
         *
         */
        event: (streamingCall) => {
            config_1.log.verbose('PuppetServiceImpl', 'event()');
            if (eventStreamManager.busy()) {
                config_1.log.error('PuppetServiceImpl', 'event() there is another event() call not end when receiving a new one.');
                const error = {
                    ...new Error('GrpcServerImpl.event() can not call twice.'),
                    code: wechaty_grpc_1.grpc.status.ALREADY_EXISTS,
                    details: 'GrpcServerImpl.event() can not call twice.',
                    metadata: streamingCall.metadata,
                };
                /**
                  * Send error from gRPC server stream:
                  *  https://github.com/grpc/grpc-node/issues/287#issuecomment-383218225
                  *
                  * Streaming RPCs
                  *  - https://grpc.io/docs/tutorials/basic/node/
                  *    Only one of 'error' or 'end' will be emitted. Finally, the 'status' event fires when the server sends the status.
                  */
                streamingCall.emit('error', error);
                return;
            }
            eventStreamManager.start(streamingCall);
            /**
             * If `scanPayload` is not undefined, then we emit it to downstream immediatelly
             */
            if (scanPayload) {
                eventStreamManager.grpcEmit(wechaty_grpc_1.EventType.EVENT_TYPE_SCAN, scanPayload);
            }
        },
        friendshipAccept: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipAccept()');
            try {
                const id = call.request.getId();
                await puppet.friendshipAccept(id);
                return callback(null, new wechaty_grpc_1.FriendshipAcceptResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipAccept', e, callback);
            }
        },
        friendshipAdd: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipAdd()');
            try {
                const contactId = call.request.getContactId();
                // FIXME: for backward compatibility, need to be removed after all puppet has updated.
                const hello = call.request.getHello();
                const sourceContactId = call.request.getSourceContactId();
                const sourceRoomId = call.request.getSourceRoomId();
                let friendshipAddOptions = hello;
                if (sourceContactId || sourceRoomId) {
                    friendshipAddOptions = {
                        contactId: sourceContactId === null || sourceContactId === void 0 ? void 0 : sourceContactId.getValue(),
                        hello,
                        roomId: sourceRoomId === null || sourceRoomId === void 0 ? void 0 : sourceRoomId.getValue(),
                    };
                }
                await puppet.friendshipAdd(contactId, friendshipAddOptions);
                return callback(null, new wechaty_grpc_1.FriendshipAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipAdd', e, callback);
            }
        },
        friendshipPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipPayload()');
            try {
                const id = call.request.getId();
                const payload = await puppet.friendshipPayload(id);
                const payloadReceive = payload;
                const response = new wechaty_grpc_1.FriendshipPayloadResponse();
                response.setContactId(payload.contactId);
                response.setHello(payload.hello || '');
                response.setId(payload.id);
                response.setScene(payloadReceive.scene || wechaty_puppet_1.FriendshipSceneType.Unknown);
                response.setStranger(payloadReceive.stranger || '');
                response.setTicket(payloadReceive.ticket);
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipPayload', e, callback);
            }
        },
        friendshipSearchPhone: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipSearchPhone()');
            try {
                const phone = call.request.getPhone();
                const contactId = await puppet.friendshipSearchPhone(phone);
                const response = new wechaty_grpc_1.FriendshipSearchPhoneResponse();
                if (contactId) {
                    const contactIdWrapper = new wechaty_grpc_1.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipSearchPhone', e, callback);
            }
        },
        friendshipSearchWeixin: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'friendshipSearchWeixin()');
            try {
                const weixin = call.request.getWeixin();
                const contactId = await puppet.friendshipSearchWeixin(weixin);
                const response = new wechaty_grpc_1.FriendshipSearchWeixinResponse();
                if (contactId) {
                    const contactIdWrapper = new wechaty_grpc_1.StringValue();
                    contactIdWrapper.setValue(contactId);
                    response.setContactId(contactIdWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('friendshipSearchWeixin', e, callback);
            }
        },
        logout: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'logout()');
            void call; // empty arguments
            try {
                await puppet.logout();
                return callback(null, new wechaty_grpc_1.LogoutResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('logout', e, callback);
            }
        },
        messageContact: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageContact()');
            try {
                const id = call.request.getId();
                const contactId = await puppet.messageContact(id);
                const response = new wechaty_grpc_1.MessageContactResponse();
                response.setId(contactId);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageContact', e, callback);
            }
        },
        /**
         * @deprecated: should not use this API because it will be changed to
         *  `messageFileStream` after Dec 31, 2021
         */
        messageFile: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageFile()');
            try {
                const id = call.request.getId();
                const fileBox = await puppet.messageFile(id);
                const response = new wechaty_grpc_1.MessageFileResponse();
                response.setFilebox(await serialize_file_box_1.serializeFileBox(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageFile', e, callback);
            }
        },
        messageFileStream: async (call) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageFileStream()');
            try {
                const id = call.request.getId();
                const fileBox = await puppet.messageFile(id);
                const response = await mod_1.packFileBoxToPb(wechaty_grpc_1.MessageFileStreamResponse)(fileBox);
                response.on('error', e => call.destroy(e));
                response.pipe(call);
            }
            catch (e) {
                config_1.log.error('PuppetServiceImpl', 'grpcError() messageFileStream() rejection: %s', e && e.message);
                call.destroy(e);
            }
        },
        messageForward: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageForward()');
            try {
                const conversationId = call.request.getConversationId();
                const messageId = call.request.getMessageId();
                const id = await puppet.messageForward(conversationId, messageId);
                const response = new wechaty_grpc_1.MessageForwardResponse();
                if (id) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(id);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageForward', e, callback);
            }
        },
        /**
         * @deprecated: should not use this API because it will be changed to
         *  `messageFileStream` after Dec 31, 2021
         */
        messageImage: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageImage()');
            try {
                const id = call.request.getId();
                const type = call.request.getType();
                const fileBox = await puppet.messageImage(id, type);
                const response = new wechaty_grpc_1.MessageImageResponse();
                response.setFilebox(await serialize_file_box_1.serializeFileBox(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageImage', e, callback);
            }
        },
        messageImageStream: async (call) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageImageStream()');
            try {
                const id = call.request.getId();
                const type = call.request.getType();
                const fileBox = await puppet.messageImage(id, type);
                const response = await mod_1.packFileBoxToPb(wechaty_grpc_1.MessageImageStreamResponse)(fileBox);
                response.on('error', e => call.destroy(e));
                response.pipe(call);
            }
            catch (e) {
                config_1.log.error('PuppetServiceImpl', 'grpcError() messageImageStream() rejection: %s', e && e.message);
                call.destroy(e);
            }
        },
        messageMiniProgram: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageMiniProgram()');
            try {
                const id = call.request.getId();
                const payload = await puppet.messageMiniProgram(id);
                const response = new wechaty_grpc_1.MessageMiniProgramResponse();
                response.setMiniProgram(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageMiniProgram', e, callback);
            }
        },
        messagePayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messagePayload()');
            try {
                const id = call.request.getId();
                const payload = await puppet.messagePayload(id);
                const mentionIdList = ('mentionIdList' in payload)
                    ? payload.mentionIdList || []
                    : [];
                const response = new wechaty_grpc_1.MessagePayloadResponse();
                response.setFilename(payload.filename || '');
                response.setFromId(payload.fromId || '');
                response.setId(payload.id);
                response.setMentionIdsList(mentionIdList);
                response.setRoomId(payload.roomId || '');
                response.setText(payload.text || '');
                response.setTimestamp(Math.floor(payload.timestamp));
                response.setToId(payload.toId || '');
                response.setType(payload.type);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messagePayload', e, callback);
            }
        },
        messageRecall: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageRecall()');
            try {
                const id = call.request.getId();
                const success = await puppet.messageRecall(id);
                const response = new wechaty_grpc_1.MessageRecallResponse();
                response.setSuccess(success);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageRecall', e, callback);
            }
        },
        messageSendContact: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendContact()');
            try {
                const conversationId = call.request.getConversationId();
                const contactId = call.request.getContactId();
                const messageId = await puppet.messageSendContact(conversationId, contactId);
                const response = new wechaty_grpc_1.MessageSendContactResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendContact', e, callback);
            }
        },
        messageSendFile: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendFile()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getFilebox();
                const fileBox = wechaty_puppet_1.FileBox.fromJSON(jsonText);
                const messageId = await puppet.messageSendFile(conversationId, fileBox);
                const response = new wechaty_grpc_1.MessageSendFileResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendFile', e, callback);
            }
        },
        messageSendFileStream: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendFileStream()');
            try {
                const requestArgs = await mod_1.unpackConversationIdFileBoxArgsFromPb(call);
                const conversationId = requestArgs.conversationId;
                const fileBox = requestArgs.fileBox;
                const messageId = await puppet.messageSendFile(conversationId, fileBox);
                const response = new wechaty_grpc_1.MessageSendFileStreamResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendFileStream', e, callback);
            }
        },
        messageSendMiniProgram: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendMiniProgram()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getMiniProgram();
                const payload = JSON.parse(jsonText);
                const messageId = await puppet.messageSendMiniProgram(conversationId, payload);
                const response = new wechaty_grpc_1.MessageSendMiniProgramResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendMiniProgram', e, callback);
            }
        },
        messageSendText: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendText()');
            try {
                const conversationId = call.request.getConversationId();
                const text = call.request.getText();
                const mentionIdList = call.request.getMentonalIdsList();
                const messageId = await puppet.messageSendText(conversationId, text, mentionIdList);
                const response = new wechaty_grpc_1.MessageSendTextResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendText', e, callback);
            }
        },
        messageSendUrl: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageSendUrl()');
            try {
                const conversationId = call.request.getConversationId();
                const jsonText = call.request.getUrlLink();
                const payload = JSON.parse(jsonText);
                const messageId = await puppet.messageSendUrl(conversationId, payload);
                const response = new wechaty_grpc_1.MessageSendUrlResponse();
                if (messageId) {
                    const idWrapper = new wechaty_grpc_1.StringValue();
                    idWrapper.setValue(messageId);
                    response.setId(idWrapper);
                }
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageSendUrl', e, callback);
            }
        },
        messageUrl: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'messageUrl()');
            try {
                const id = call.request.getId();
                const payload = await puppet.messageUrl(id);
                const response = new wechaty_grpc_1.MessageUrlResponse();
                response.setUrlLink(JSON.stringify(payload));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('messageUrl', e, callback);
            }
        },
        roomAdd: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomAdd()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                await puppet.roomAdd(roomId, contactId);
                return callback(null, new wechaty_grpc_1.RoomAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAdd', e, callback);
            }
        },
        roomAnnounce: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomAnnounce()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const textWrapper = call.request.getText();
                    if (textWrapper) {
                        const text = textWrapper.getValue();
                        await puppet.roomAnnounce(roomId, text);
                        return callback(null, new wechaty_grpc_1.RoomAnnounceResponse());
                    }
                }
                /**
                 * Get
                 */
                const text = await puppet.roomAnnounce(roomId);
                const textWrapper = new wechaty_grpc_1.StringValue();
                textWrapper.setValue(text);
                const response = new wechaty_grpc_1.RoomAnnounceResponse();
                response.setText(textWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAnnounce', e, callback);
            }
        },
        roomAvatar: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomAvatar()');
            try {
                const roomId = call.request.getId();
                const fileBox = await puppet.roomAvatar(roomId);
                const response = new wechaty_grpc_1.RoomAvatarResponse();
                response.setFilebox(await serialize_file_box_1.serializeFileBox(fileBox));
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomAvatar', e, callback);
            }
        },
        roomCreate: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomCreate()');
            try {
                const contactIdList = call.request.getContactIdsList();
                const topic = call.request.getTopic();
                const roomId = await puppet.roomCreate(contactIdList, topic);
                const response = new wechaty_grpc_1.RoomCreateResponse();
                response.setId(roomId);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomCreate', e, callback);
            }
        },
        roomDel: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomDel()');
            try {
                const roomId = call.request.getId();
                const contactId = call.request.getContactId();
                await puppet.roomDel(roomId, contactId);
                return callback(null, new wechaty_grpc_1.RoomDelResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomDel', e, callback);
            }
        },
        roomInvitationAccept: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomInvitationAccept()');
            try {
                const id = call.request.getId();
                await puppet.roomInvitationAccept(id);
                return callback(null, new wechaty_grpc_1.RoomInvitationAcceptResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomInvitationAccept', e, callback);
            }
        },
        roomInvitationPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomInvitationPayload()');
            try {
                const roomInvitationId = call.request.getId();
                /**
                  * Set
                  */
                {
                    const payloadWrapper = call.request.getPayload();
                    if (payloadWrapper) {
                        const jsonText = payloadWrapper.getValue();
                        const payload = JSON.parse(jsonText);
                        await puppet.roomInvitationPayload(roomInvitationId, payload);
                        return callback(null, new wechaty_grpc_1.RoomInvitationPayloadResponse());
                    }
                }
                /**
                 * Get
                 */
                const payload = await puppet.roomInvitationPayload(roomInvitationId);
                const response = new wechaty_grpc_1.RoomInvitationPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInvitation(payload.invitation);
                response.setInviterId(payload.inviterId);
                response.setReceiverId(payload.receiverId);
                response.setMemberCount(payload.memberCount);
                response.setMemberIdsList(payload.memberIdList);
                response.setTimestamp(Math.floor(payload.timestamp));
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomInvitationPayload', e, callback);
            }
        },
        roomList: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomList()');
            void call;
            try {
                const roomIdList = await puppet.roomList();
                const response = new wechaty_grpc_1.RoomListResponse();
                response.setIdsList(roomIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomList', e, callback);
            }
        },
        roomMemberList: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomMemberList()');
            try {
                const roomId = call.request.getId();
                const roomMemberIdList = await puppet.roomMemberList(roomId);
                const response = new wechaty_grpc_1.RoomMemberListResponse();
                response.setMemberIdsList(roomMemberIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomMemberList', e, callback);
            }
        },
        roomMemberPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomMemberPayload()');
            try {
                const roomId = call.request.getId();
                const memberId = call.request.getMemberId();
                const payload = await puppet.roomMemberPayload(roomId, memberId);
                const response = new wechaty_grpc_1.RoomMemberPayloadResponse();
                response.setAvatar(payload.avatar);
                response.setId(payload.id);
                response.setInviterId(payload.inviterId || '');
                response.setName(payload.name);
                response.setRoomAlias(payload.roomAlias || '');
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomMemberPayload', e, callback);
            }
        },
        roomPayload: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomPayload()');
            try {
                const roomId = call.request.getId();
                const payload = await puppet.roomPayload(roomId);
                const response = new wechaty_grpc_1.RoomPayloadResponse();
                response.setAdminIdsList(payload.adminIdList);
                response.setAvatar(payload.avatar || '');
                response.setId(payload.id);
                response.setMemberIdsList(payload.memberIdList);
                response.setOwnerId(payload.ownerId || '');
                response.setTopic(payload.topic);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomPayload', e, callback);
            }
        },
        roomQRCode: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomQRCode()');
            try {
                const roomId = call.request.getId();
                const qrcode = await puppet.roomQRCode(roomId);
                const response = new wechaty_grpc_1.RoomQRCodeResponse();
                response.setQrcode(qrcode);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomQRCode', e, callback);
            }
        },
        roomQuit: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomQuit()');
            try {
                const roomId = call.request.getId();
                await puppet.roomQuit(roomId);
                return callback(null, new wechaty_grpc_1.RoomQuitResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('roomQuit', e, callback);
            }
        },
        roomTopic: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'roomTopic()');
            try {
                const roomId = call.request.getId();
                /**
                 * Set
                 */
                {
                    const topicWrapper = call.request.getTopic();
                    if (topicWrapper) {
                        const topic = topicWrapper.getValue();
                        await puppet.roomTopic(roomId, topic);
                        return callback(null, new wechaty_grpc_1.RoomTopicResponse());
                    }
                }
                /**
                 * Get
                 */
                const topic = await puppet.roomTopic(roomId);
                const topicWrapper = new wechaty_grpc_1.StringValue();
                topicWrapper.setValue(topic);
                const response = new wechaty_grpc_1.RoomTopicResponse();
                response.setTopic(topicWrapper);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('roomTopic', e, callback);
            }
        },
        start: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'start()');
            void call;
            try {
                await puppet.start();
                return callback(null, new wechaty_grpc_1.StartResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('start', e, callback);
            }
        },
        stop: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'stop()');
            void call;
            try {
                if (eventStreamManager.busy()) {
                    eventStreamManager.stop();
                }
                else {
                    config_1.log.error('PuppetServiceImpl', 'stop() eventStreamManager is not busy?');
                }
                await puppet.stop();
                readyPayload = undefined;
                return callback(null, new wechaty_grpc_1.StopResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('stop', e, callback);
            }
        },
        tagContactAdd: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactAdd()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                await puppet.tagContactAdd(tagId, contactId);
                return callback(null, new wechaty_grpc_1.TagContactAddResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactAdd', e, callback);
            }
        },
        tagContactDelete: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactDelete()');
            try {
                const tagId = call.request.getId();
                await puppet.tagContactDelete(tagId);
                return callback(null, new wechaty_grpc_1.TagContactDeleteResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactDelete', e, callback);
            }
        },
        tagContactList: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactList()');
            try {
                const contactIdWrapper = call.request.getContactId();
                /**
                 * for a specific contact
                 */
                if (contactIdWrapper) {
                    const contactId = contactIdWrapper.getValue();
                    const tagIdList = await puppet.tagContactList(contactId);
                    const response = new wechaty_grpc_1.TagContactListResponse();
                    response.setIdsList(tagIdList);
                    return callback(null, new wechaty_grpc_1.TagContactListResponse());
                }
                /**
                 * get all tags for all contact
                 */
                const tagIdList = await puppet.tagContactList();
                const response = new wechaty_grpc_1.TagContactListResponse();
                response.setIdsList(tagIdList);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactList', e, callback);
            }
        },
        tagContactRemove: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'tagContactRemove()');
            try {
                const tagId = call.request.getId();
                const contactId = call.request.getContactId();
                await puppet.tagContactRemove(tagId, contactId);
                return callback(null, new wechaty_grpc_1.TagContactRemoveResponse());
            }
            catch (e) {
                return grpc_error_1.grpcError('tagContactRemove', e, callback);
            }
        },
        version: async (call, callback) => {
            config_1.log.verbose('PuppetServiceImpl', 'version() v%s', puppet.version());
            void call;
            try {
                const version = puppet.version();
                const response = new wechaty_grpc_1.VersionResponse();
                response.setVersion(version);
                return callback(null, response);
            }
            catch (e) {
                return grpc_error_1.grpcError('version', e, callback);
            }
        },
    };
    return puppetServerImpl;
}
exports.puppetImplementation = puppetImplementation;
//# sourceMappingURL=puppet-implementation.js.map