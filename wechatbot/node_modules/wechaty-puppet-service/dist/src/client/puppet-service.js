"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PuppetService = void 0;
const util_1 = __importDefault(require("util"));
const file_box_1 = require("file-box");
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const wechaty_puppet_1 = require("wechaty-puppet");
const wechaty_grpc_1 = require("wechaty-grpc");
const config_1 = require("../config");
const event_type_rev_1 = require("../event-type-rev");
const mod_1 = require("../file-box-stream/mod");
const serialize_file_box_1 = require("../server/serialize-file-box");
const recover_1 = require("./recover$");
const MAX_SERVICE_IP_DISCOVERY_RETRIES = 10;
const MAX_GRPC_CONNECTION_RETRIES = 5;
class PuppetService extends wechaty_puppet_1.Puppet {
    constructor(options = {}) {
        super(options);
        this.options = options;
        options.endpoint = config_1.GET_WECHATY_PUPPET_SERVICE_ENDPOINT(options.endpoint);
        options.token = config_1.GET_WECHATY_PUPPET_SERVICE_TOKEN(options.token);
        // this.heartbeatDebounceQueue = new DebounceQueue(HEARTBEAT_DEBOUNCE_TIME * 1000)
        this.cleanCallbackList = [];
    }
    async discoverServiceIp(token) {
        config_1.log.verbose('PuppetService', 'discoverServiceIp(%s)', token);
        const chatieEndpoint = config_1.GET_WECHATY_SERVICE_DISCOVERY_ENDPOINT();
        try {
            return Promise.race([
                this.getServiceIp(chatieEndpoint, token),
                // eslint-disable-next-line promise/param-names
                new Promise((_, reject) => setTimeout(() => reject(new Error('ETIMEOUT')), 
                /**
                 * Huan(202106): Better deal with the timeout error
                 *  Related to https://github.com/wechaty/wechaty/issues/2197
                 */
                5 * 1000)),
            ]);
        }
        catch (e) {
            config_1.log.warn(`discoverServiceIp() failed to get any ip info from all service endpoints.\n${e.stack}`);
            return {};
        }
    }
    async getServiceIp(endpoint, token) {
        const url = `${endpoint}/v0/hosties/${token}`;
        return new Promise((resolve, reject) => {
            const httpClient = /^https:\/\//.test(url) ? https_1.default : http_1.default;
            httpClient.get(url, function (res) {
                let body = '';
                res.on('data', function (chunk) {
                    body += chunk;
                });
                res.on('end', function () {
                    resolve(JSON.parse(body));
                });
            }).on('error', function (e) {
                reject(new Error(`PuppetService discoverServiceIp() endpoint<${url}> rejection: ${e}`));
            });
        });
    }
    async startGrpcClient() {
        config_1.log.verbose('PuppetService', 'startGrpcClient()');
        if (this.grpcClient) {
            throw new Error('puppetClient had already initialized');
        }
        let endpoint = this.options.endpoint;
        if (!endpoint) {
            let serviceIpResult = await this.discoverServiceIp(this.options.token);
            let retries = MAX_SERVICE_IP_DISCOVERY_RETRIES;
            while (retries > 0 && (!serviceIpResult.ip || serviceIpResult.ip === '0.0.0.0')) {
                config_1.log.warn(`No endpoint when starting grpc client, ${retries--} retry left. Reconnecting in 10 seconds...`);
                await new Promise(resolve => setTimeout(resolve, 10 * 1000));
                serviceIpResult = await this.discoverServiceIp(this.options.token);
            }
            if (!serviceIpResult.ip || serviceIpResult.ip === '0.0.0.0') {
                return;
            }
            endpoint = serviceIpResult.ip + ':' + serviceIpResult.port;
        }
        const clientOptions = {
            ...config_1.GRPC_OPTIONS,
            'grpc.default_authority': this.options.token,
        };
        this.grpcClient = new wechaty_grpc_1.PuppetClient(endpoint, // 'localhost:50051',
        wechaty_grpc_1.grpc.credentials.createInsecure(), clientOptions);
    }
    async stopGrpcClient() {
        config_1.log.verbose('PuppetService', 'stopGrpcClient()');
        if (!this.grpcClient) {
            throw new Error('puppetClient had not initialized');
        }
        this.grpcClient.close();
        this.grpcClient = undefined;
    }
    async start() {
        await super.start();
        config_1.log.verbose('PuppetService', 'start()');
        if (!this.options.token) {
            const tokenNotFoundError = 'wechaty-puppet-service: WECHATY_PUPPET_SERVICE_TOKEN not found';
            console.error([
                '',
                tokenNotFoundError,
                '(save token to WECHATY_PUPPET_SERVICE_TOKEN env var or pass it to puppet options is required.).',
                '',
                'To learn how to get Wechaty Puppet Service Token,',
                'please visit <https://wechaty.js.org/docs/puppet-services/>',
                'to see our Wechaty Puppet Service Providers.',
                '',
            ].join('\n'));
            throw new Error(tokenNotFoundError);
        }
        if (this.state.on()) {
            config_1.log.warn('PuppetService', 'start() is called on a ON puppet. await ready(on) and return.');
            await this.state.ready('on');
            return;
        }
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
        }
        this.state.on('pending');
        try {
            await this.startGrpcClient();
            if (!this.grpcClient) {
                config_1.log.warn('PuppetService', 'start() failed to start grpc client, resetting self...');
                this.emit('reset', { data: 'failed to connect grpc client' });
                return;
            }
            await this.startGrpcStream();
            // this.startDing()
            await this.grpcClientStart();
            this.state.on(true);
            this.recoverSubscription = recover_1.recover$(this).subscribe(x => config_1.log.verbose('PuppetService', 'constructor() recover$().subscribe() next(%s)', JSON.stringify(x)), e => config_1.log.error('PuppetService', 'constructor() recover$().subscribe() error(%s)', e), () => config_1.log.verbose('PuppetService', 'constructor() recover$().subscribe() complete()'));
        }
        catch (e) {
            config_1.log.error('PuppetService', 'start() rejection: %s\n%s', e && e.message, e.stack);
            if (this.grpcClient) {
                this.grpcClient.close();
                this.grpcClient = undefined;
            }
            this.state.off(true);
            throw e;
        }
    }
    async stop() {
        await super.stop();
        config_1.log.verbose('PuppetService', 'stop()');
        if (this.state.off()) {
            config_1.log.warn('PuppetService', 'stop() is called on a OFF puppet. await ready(off) and return.');
            await this.state.ready('off');
            return;
        }
        this.state.off('pending');
        if (this.recoverSubscription) {
            this.recoverSubscription.unsubscribe();
            this.recoverSubscription = undefined;
        }
        while (this.cleanCallbackList.length > 0) {
            const cb = this.cleanCallbackList.pop();
            try {
                cb && cb();
            }
            catch (e) {
                config_1.log.error('PuppetService', 'stop() cleanCallbackList rejection: %s', e.message);
            }
        }
        if (this.grpcClient) {
            try {
                this.stopGrpcStream();
                await util_1.default.promisify(this.grpcClient.stop
                    .bind(this.grpcClient))(new wechaty_grpc_1.StopRequest());
                await this.stopGrpcClient();
            }
            catch (e) {
                config_1.log.error('PuppetService', 'stop() stop GRPC rejection: %s', e.message);
            }
            finally {
                this.grpcClient = undefined;
            }
        }
        else {
            config_1.log.warn('PuppetService', 'stop() this.grpcClient not exist');
        }
        if (this.logonoff()) {
            this.emit('logout', {
                contactId: this.selfId(),
                data: 'PuppetService stop()',
            });
            this.id = undefined;
        }
        this.state.off(true);
    }
    async startGrpcStream() {
        config_1.log.verbose('PuppetService', 'startGrpcStream()');
        if (this.eventStream) {
            throw new Error('event stream exists');
        }
        let retry = MAX_GRPC_CONNECTION_RETRIES;
        while (!this.eventStream) {
            try {
                this.eventStream = this.grpcClient.event(new wechaty_grpc_1.EventRequest());
            }
            catch (e) {
                if (retry-- > 0) {
                    config_1.log.verbose('PuppetService', `startGrpcStream() connection failed, ${retry} retries left, reconnecting in 2 seconds...`);
                    await new Promise(resolve => setTimeout(resolve, 2 * 1000));
                }
                else {
                    config_1.log.error('PuppetService', `startGrpcStream() connection failed and max retries has been reached. Error:\n${e.stack}`);
                    break;
                }
            }
        }
        if (!this.eventStream) {
            this.emit('reset', { data: 'startGrpcStream() failed to connect to grpc server' });
            return;
        }
        this.eventStream
            .on('data', this.onGrpcStreamEvent.bind(this))
            .on('end', () => {
            config_1.log.verbose('PuppetService', 'startGrpcStream() eventStream.on(end)');
        })
            .on('error', (e) => {
            // https://github.com/wechaty/wechaty-puppet-service/issues/16
            config_1.log.verbose('PuppetService', 'startGrpcStream() eventStream.on(error) %s', e);
            const reason = 'startGrpcStream() eventStream.on(error) ' + e;
            /**
             * The `Puppet` class have a throttleQueue for receiving the `reset` events
             *  and it's the `Puppet` class's duty for call the `puppet.reset()` to reset the puppet.
             */
            this.emit('reset', { data: reason });
        })
            .on('cancel', (...args) => {
            config_1.log.verbose('PuppetService', 'startGrpcStream() eventStream.on(cancel), %s', JSON.stringify(args));
        });
    }
    async grpcClientStart() {
        config_1.log.verbose('PuppetService', 'grpcClientStart()');
        try {
            await util_1.default.promisify(this.grpcClient.start
                .bind(this.grpcClient))(new wechaty_grpc_1.StartRequest());
        }
        catch (error) {
            const msgDetail = error.details;
            if (msgDetail === 'No connection established') {
                await new Promise(resolve => setTimeout(resolve, 2000));
                this.emit('reset', { data: msgDetail });
            }
            else {
                throw error;
            }
        }
    }
    onGrpcStreamEvent(event) {
        const type = event.getType();
        const payload = event.getPayload();
        config_1.log.verbose('PuppetService', 'onGrpcStreamEvent({type:%s(%s), payload:"%s"})', event_type_rev_1.EventTypeRev[type], type, payload);
        if (type !== wechaty_grpc_1.EventType.EVENT_TYPE_HEARTBEAT) {
            this.emit('heartbeat', {
                data: `onGrpcStreamEvent(${event_type_rev_1.EventTypeRev[type]})`,
            });
        }
        switch (type) {
            case wechaty_grpc_1.EventType.EVENT_TYPE_DONG:
                this.emit('dong', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_ERROR:
                this.emit('error', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_HEARTBEAT:
                this.emit('heartbeat', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_FRIENDSHIP:
                this.emit('friendship', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_LOGIN:
                {
                    const loginPayload = JSON.parse(payload);
                    this.id = loginPayload.contactId;
                    this.emit('login', loginPayload);
                }
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_LOGOUT:
                this.id = undefined;
                this.emit('logout', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_DIRTY:
                this.emit('dirty', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_MESSAGE:
                this.emit('message', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_READY:
                this.emit('ready', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_ROOM_INVITE:
                this.emit('room-invite', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_ROOM_JOIN:
                this.emit('room-join', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_ROOM_LEAVE:
                this.emit('room-leave', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_ROOM_TOPIC:
                this.emit('room-topic', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_SCAN:
                this.emit('scan', JSON.parse(payload));
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_RESET:
                config_1.log.warn('PuppetService', 'onGrpcStreamEvent() got an EventType.EVENT_TYPE_RESET ?');
                // the `reset` event should be dealed not send out
                break;
            case wechaty_grpc_1.EventType.EVENT_TYPE_UNSPECIFIED:
                config_1.log.error('PuppetService', 'onGrpcStreamEvent() got an EventType.EVENT_TYPE_UNSPECIFIED ?');
                break;
            default:
                // Huan(202003): in default, the `type` type should be `never`, please check.
                throw new Error('eventType ' + type + ' unsupported! (code should not reach here)');
        }
    }
    stopGrpcStream() {
        config_1.log.verbose('PuppetService', 'stopGrpcStream()');
        if (!this.eventStream) {
            config_1.log.verbose('PuppetService', 'no eventStream when stop, skip destroy.');
            return;
        }
        /**
         * Huan(202003):
         *  destroy() will be enough to terminate a stream call.
         *  cancel() is not needed.
         */
        // this.eventStream.cancel()
        this.eventStream.destroy();
        this.eventStream = undefined;
    }
    async logout() {
        config_1.log.verbose('PuppetService', 'logout()');
        if (!this.id) {
            throw new Error('logout before login?');
        }
        try {
            await util_1.default.promisify(this.grpcClient.logout.bind(this.grpcClient)
                .bind(this.grpcClient))(new wechaty_grpc_1.LogoutRequest());
        }
        catch (e) {
            config_1.log.error('PuppetService', 'logout() rejection: %s', e && e.message);
            throw e;
        }
    }
    ding(data) {
        config_1.log.silly('PuppetService', 'ding(%s)', data);
        const request = new wechaty_grpc_1.DingRequest();
        request.setData(data || '');
        if (!this.grpcClient) {
            config_1.log.info('PuppetService', 'ding() Skip ding since grpcClient is not connected.');
            return;
        }
        this.grpcClient.ding(request, (error, _response) => {
            if (error) {
                config_1.log.error('PuppetService', 'ding() rejection: %s', error);
            }
        });
    }
    async dirtyPayload(type, id) {
        await super.dirtyPayload(type, id);
        if (!this.grpcClient) {
            throw new Error('PuppetService dirtyPayload() can not execute due to no grpcClient.');
        }
        const request = new wechaty_grpc_1.DirtyPayloadRequest();
        request.setId(id);
        request.setType(type);
        try {
            await util_1.default.promisify(this.grpcClient.dirtyPayload.bind(this.grpcClient)
                .bind(this.grpcClient))(request);
        }
        catch (e) {
            config_1.log.error('PuppetService', 'dirtyPayload() rejection: %s', e && e.message);
            throw e;
        }
    }
    unref() {
        config_1.log.verbose('PuppetService', 'unref()');
        super.unref();
    }
    async contactAlias(contactId, alias) {
        config_1.log.verbose('PuppetService', 'contactAlias(%s, %s)', contactId, alias);
        /**
         * Get alias
         */
        if (typeof alias === 'undefined') {
            const request = new wechaty_grpc_1.ContactAliasRequest();
            request.setId(contactId);
            const response = await util_1.default.promisify(this.grpcClient.contactAlias.bind(this.grpcClient))(request);
            const aliasWrapper = response.getAlias();
            if (!aliasWrapper) {
                throw new Error('can not get aliasWrapper');
            }
            return aliasWrapper.getValue();
        }
        /**
         * Set alias
         */
        const aliasWrapper = new wechaty_grpc_1.StringValue();
        aliasWrapper.setValue(alias || ''); // null -> '', in server, we treat '' as null
        const request = new wechaty_grpc_1.ContactAliasRequest();
        request.setId(contactId);
        request.setAlias(aliasWrapper);
        await util_1.default.promisify(this.grpcClient.contactAlias.bind(this.grpcClient))(request);
    }
    async contactPhone(contactId, phoneList) {
        config_1.log.verbose('PuppetService', 'contactPhone(%s, %s)', contactId, phoneList);
        const request = new wechaty_grpc_1.ContactPhoneRequest();
        request.setContactId(contactId);
        request.setPhoneListList(phoneList);
        await util_1.default.promisify(this.grpcClient.contactPhone.bind(this.grpcClient))(request);
    }
    async contactCorporationRemark(contactId, corporationRemark) {
        config_1.log.verbose('PuppetService', 'contactCorporationRemark(%s, %s)', contactId, corporationRemark);
        const corporationRemarkWrapper = new wechaty_grpc_1.StringValue();
        if (corporationRemark) {
            corporationRemarkWrapper.setValue(corporationRemark);
        }
        const request = new wechaty_grpc_1.ContactCorporationRemarkRequest();
        request.setContactId(contactId);
        request.setCorporationRemark(corporationRemarkWrapper);
        await util_1.default.promisify(this.grpcClient.contactCorporationRemark.bind(this.grpcClient))(request);
    }
    async contactDescription(contactId, description) {
        config_1.log.verbose('PuppetService', 'contactDescription(%s, %s)', contactId, description);
        const descriptionWrapper = new wechaty_grpc_1.StringValue();
        if (description) {
            descriptionWrapper.setValue(description);
        }
        const request = new wechaty_grpc_1.ContactDescriptionRequest();
        request.setContactId(contactId);
        request.setDescription(descriptionWrapper);
        await util_1.default.promisify(this.grpcClient.contactDescription.bind(this.grpcClient))(request);
    }
    async contactList() {
        config_1.log.verbose('PuppetService', 'contactList()');
        const response = await util_1.default.promisify(this.grpcClient.contactList.bind(this.grpcClient))(new wechaty_grpc_1.ContactListRequest());
        return response.getIdsList();
    }
    async contactAvatar(contactId, fileBox) {
        config_1.log.verbose('PuppetService', 'contactAvatar(%s)', contactId);
        /**
         * 1. set
         */
        if (fileBox) {
            const fileboxWrapper = new wechaty_grpc_1.StringValue();
            fileboxWrapper.setValue(await serialize_file_box_1.serializeFileBox(fileBox));
            const request = new wechaty_grpc_1.ContactAvatarRequest();
            request.setId(contactId);
            request.setFilebox(fileboxWrapper);
            await util_1.default.promisify(this.grpcClient.contactAvatar.bind(this.grpcClient))(request);
            return;
        }
        /**
         * 2. get
         */
        const request = new wechaty_grpc_1.ContactAvatarRequest();
        request.setId(contactId);
        const response = await util_1.default.promisify(this.grpcClient.contactAvatar.bind(this.grpcClient))(request);
        const textWrapper = response.getFilebox();
        if (!textWrapper) {
            throw new Error('can not get textWrapper');
        }
        const jsonText = textWrapper.getValue();
        return wechaty_puppet_1.FileBox.fromJSON(jsonText);
    }
    async contactRawPayload(id) {
        config_1.log.verbose('PuppetService', 'contactRawPayload(%s)', id);
        const request = new wechaty_grpc_1.ContactPayloadRequest();
        request.setId(id);
        const response = await util_1.default.promisify(this.grpcClient.contactPayload.bind(this.grpcClient))(request);
        const payload = {
            address: response.getAddress(),
            alias: response.getAlias(),
            avatar: response.getAvatar(),
            city: response.getCity(),
            corporation: response.getCorporation(),
            coworker: response.getCoworker(),
            description: response.getDescription(),
            friend: response.getFriend(),
            gender: response.getGender(),
            id: response.getId(),
            name: response.getName(),
            phone: response.getPhoneList(),
            province: response.getProvince(),
            signature: response.getSignature(),
            star: response.getStar(),
            title: response.getTitle(),
            type: response.getType(),
            weixin: response.getWeixin(),
        };
        return payload;
    }
    async contactRawPayloadParser(payload) {
        // log.silly('PuppetService', 'contactRawPayloadParser({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    async contactSelfName(name) {
        config_1.log.verbose('PuppetService', 'contactSelfName(%s)', name);
        const request = new wechaty_grpc_1.ContactSelfNameRequest();
        request.setName(name);
        await util_1.default.promisify(this.grpcClient.contactSelfName.bind(this.grpcClient))(request);
    }
    async contactSelfQRCode() {
        config_1.log.verbose('PuppetService', 'contactSelfQRCode()');
        const response = await util_1.default.promisify(this.grpcClient.contactSelfQRCode.bind(this.grpcClient))(new wechaty_grpc_1.ContactSelfQRCodeRequest());
        return response.getQrcode();
    }
    async contactSelfSignature(signature) {
        config_1.log.verbose('PuppetService', 'contactSelfSignature(%s)', signature);
        const request = new wechaty_grpc_1.ContactSelfSignatureRequest();
        request.setSignature(signature);
        await util_1.default.promisify(this.grpcClient.contactSelfSignature.bind(this.grpcClient))(request);
    }
    /**
     *
     * Conversation
     *
     */
    conversationReadMark(conversationId, hasRead = true) {
        config_1.log.verbose('PuppetService', 'conversationMarkRead(%s, %s)', conversationId, hasRead);
        wechaty_puppet_1.throwUnsupportedError('not implemented. See https://github.com/wechaty/wechaty-puppet/pull/132');
    }
    /**
     *
     * Message
     *
     */
    async messageMiniProgram(messageId) {
        config_1.log.verbose('PuppetService', 'messageMiniProgram(%s)', messageId);
        const request = new wechaty_grpc_1.MessageMiniProgramRequest();
        request.setId(messageId);
        const response = await util_1.default.promisify(this.grpcClient.messageMiniProgram.bind(this.grpcClient))(request);
        const jsonText = response.getMiniProgram();
        const payload = JSON.parse(jsonText);
        return payload;
    }
    async messageImage(messageId, imageType) {
        config_1.log.verbose('PuppetService', 'messageImage(%s, %s[%s])', messageId, imageType, wechaty_puppet_1.ImageType[imageType]);
        const request = new wechaty_grpc_1.MessageImageStreamRequest();
        request.setId(messageId);
        request.setType(imageType);
        if (!this.grpcClient) {
            throw new Error('Can not get image from message since no grpc client.');
        }
        const pbStream = this.grpcClient.messageImageStream(request);
        const fileBox = await mod_1.unpackFileBoxFromPb(pbStream);
        // const fileBoxChunkStream = unpackFileBoxChunk(stream)
        // return unpackFileBox(fileBoxChunkStream)
        return fileBox;
    }
    async messageContact(messageId) {
        config_1.log.verbose('PuppetService', 'messageContact(%s)', messageId);
        const request = new wechaty_grpc_1.MessageContactRequest();
        request.setId(messageId);
        const response = await util_1.default.promisify(this.grpcClient.messageContact.bind(this.grpcClient))(request);
        const contactId = response.getId();
        return contactId;
    }
    async messageSendMiniProgram(conversationId, miniProgramPayload) {
        config_1.log.verbose('PuppetService', 'messageSendMiniProgram(%s)', conversationId, JSON.stringify(miniProgramPayload));
        const request = new wechaty_grpc_1.MessageSendMiniProgramRequest();
        request.setConversationId(conversationId);
        request.setMiniProgram(JSON.stringify(miniProgramPayload));
        const response = await util_1.default.promisify(this.grpcClient.messageSendMiniProgram.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageRecall(messageId) {
        config_1.log.verbose('PuppetService', 'messageRecall(%s)', messageId);
        const request = new wechaty_grpc_1.MessageRecallRequest();
        request.setId(messageId);
        const response = await util_1.default.promisify(this.grpcClient.messageRecall.bind(this.grpcClient))(request);
        return response.getSuccess();
    }
    async messageFile(id) {
        config_1.log.verbose('PuppetService', 'messageFile(%s)', id);
        const request = new wechaty_grpc_1.MessageFileStreamRequest();
        request.setId(id);
        if (!this.grpcClient) {
            throw new Error('Can not get file from message since no grpc client.');
        }
        const pbStream = this.grpcClient.messageFileStream(request);
        // const fileBoxChunkStream = unpackFileBoxChunk(pbStream)
        // return unpackFileBox(fileBoxChunkStream)
        const fileBox = await mod_1.unpackFileBoxFromPb(pbStream);
        return fileBox;
    }
    async messageForward(conversationId, messageId) {
        config_1.log.verbose('PuppetService', 'messageForward(%s, %s)', conversationId, messageId);
        const request = new wechaty_grpc_1.MessageForwardRequest();
        request.setConversationId(conversationId);
        request.setMessageId(messageId);
        const response = await util_1.default.promisify(this.grpcClient.messageForward.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageRawPayload(id) {
        config_1.log.verbose('PuppetService', 'messageRawPayload(%s)', id);
        const request = new wechaty_grpc_1.MessagePayloadRequest();
        request.setId(id);
        const response = await util_1.default.promisify(this.grpcClient.messagePayload.bind(this.grpcClient))(request);
        const payload = {
            filename: response.getFilename(),
            fromId: response.getFromId(),
            id: response.getId(),
            mentionIdList: response.getMentionIdsList(),
            roomId: response.getRoomId(),
            text: response.getText(),
            timestamp: response.getTimestamp(),
            toId: response.getToId(),
            type: response.getType(),
        };
        return payload;
    }
    async messageRawPayloadParser(payload) {
        // log.silly('PuppetService', 'messagePayload({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    async messageSendText(conversationId, text, mentionIdList) {
        config_1.log.verbose('PuppetService', 'messageSend(%s, %s)', conversationId, text);
        const request = new wechaty_grpc_1.MessageSendTextRequest();
        request.setConversationId(conversationId);
        request.setText(text);
        if (typeof mentionIdList !== 'undefined') {
            request.setMentonalIdsList(mentionIdList);
        }
        const response = await util_1.default.promisify(this.grpcClient.messageSendText.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageSendFile(conversationId, file) {
        config_1.log.verbose('PuppetService', 'messageSend(%s, %s)', conversationId, file);
        const fileBoxStreamTypes = [
            file_box_1.FileBoxType.Base64,
            file_box_1.FileBoxType.Buffer,
            file_box_1.FileBoxType.File,
            file_box_1.FileBoxType.Stream,
        ];
        if (fileBoxStreamTypes.includes(file.type())) {
            return this.messageSendFileStream(conversationId, file);
        }
        else {
            return this.messageSendFileNonStream(conversationId, file);
        }
    }
    async messageSendContact(conversationId, contactId) {
        config_1.log.verbose('PuppetService', 'messageSend("%s", %s)', conversationId, contactId);
        const request = new wechaty_grpc_1.MessageSendContactRequest();
        request.setConversationId(conversationId);
        request.setContactId(contactId);
        const response = await util_1.default.promisify(this.grpcClient.messageSendContact.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageSendUrl(conversationId, urlLinkPayload) {
        config_1.log.verbose('PuppetService', 'messageSendUrl("%s", %s)', conversationId, JSON.stringify(urlLinkPayload));
        const request = new wechaty_grpc_1.MessageSendUrlRequest();
        request.setConversationId(conversationId);
        request.setUrlLink(JSON.stringify(urlLinkPayload));
        const response = await util_1.default.promisify(this.grpcClient.messageSendUrl.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageUrl(messageId) {
        config_1.log.verbose('PuppetService', 'messageUrl(%s)', messageId);
        const request = new wechaty_grpc_1.MessageUrlRequest();
        request.setId(messageId);
        const response = await util_1.default.promisify(this.grpcClient.messageUrl.bind(this.grpcClient))(request);
        const jsonText = response.getUrlLink();
        const payload = JSON.parse(jsonText);
        return payload;
    }
    /**
     *
     * Room
     *
     */
    async roomRawPayload(id) {
        config_1.log.verbose('PuppetService', 'roomRawPayload(%s)', id);
        const request = new wechaty_grpc_1.RoomPayloadRequest();
        request.setId(id);
        const response = await util_1.default.promisify(this.grpcClient.roomPayload.bind(this.grpcClient))(request);
        const payload = {
            adminIdList: response.getAdminIdsList(),
            avatar: response.getAvatar(),
            id: response.getId(),
            memberIdList: response.getMemberIdsList(),
            ownerId: response.getOwnerId(),
            topic: response.getTopic(),
        };
        return payload;
    }
    async roomRawPayloadParser(payload) {
        // log.silly('PuppetService', 'roomRawPayloadParser({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    async roomList() {
        config_1.log.verbose('PuppetService', 'roomList()');
        const response = await util_1.default.promisify(this.grpcClient.roomList.bind(this.grpcClient))(new wechaty_grpc_1.RoomListRequest());
        return response.getIdsList();
    }
    async roomDel(roomId, contactId) {
        config_1.log.verbose('PuppetService', 'roomDel(%s, %s)', roomId, contactId);
        const request = new wechaty_grpc_1.RoomDelRequest();
        request.setId(roomId);
        request.setContactId(contactId);
        await util_1.default.promisify(this.grpcClient.roomDel.bind(this.grpcClient))(request);
    }
    async roomAvatar(roomId) {
        config_1.log.verbose('PuppetService', 'roomAvatar(%s)', roomId);
        const request = new wechaty_grpc_1.RoomAvatarRequest();
        request.setId(roomId);
        const response = await util_1.default.promisify(this.grpcClient.roomAvatar.bind(this.grpcClient))(request);
        const jsonText = response.getFilebox();
        return wechaty_puppet_1.FileBox.fromJSON(jsonText);
    }
    async roomAdd(roomId, contactId) {
        config_1.log.verbose('PuppetService', 'roomAdd(%s, %s)', roomId, contactId);
        const request = new wechaty_grpc_1.RoomAddRequest();
        request.setId(roomId);
        request.setContactId(contactId);
        await util_1.default.promisify(this.grpcClient.roomAdd.bind(this.grpcClient))(request);
    }
    async roomTopic(roomId, topic) {
        config_1.log.verbose('PuppetService', 'roomTopic(%s, %s)', roomId, topic);
        /**
         * Get
         */
        if (typeof topic === 'undefined') {
            const request = new wechaty_grpc_1.RoomTopicRequest();
            request.setId(roomId);
            const response = await util_1.default.promisify(this.grpcClient.roomTopic.bind(this.grpcClient))(request);
            const topicWrapper = response.getTopic();
            if (topicWrapper) {
                return topicWrapper.getValue();
            }
            return '';
        }
        /**
         * Set
         */
        const topicWrapper = new wechaty_grpc_1.StringValue();
        topicWrapper.setValue(topic);
        const request = new wechaty_grpc_1.RoomTopicRequest();
        request.setId(roomId);
        request.setTopic(topicWrapper);
        await util_1.default.promisify(this.grpcClient.roomTopic.bind(this.grpcClient))(request);
    }
    async roomCreate(contactIdList, topic) {
        config_1.log.verbose('PuppetService', 'roomCreate(%s, %s)', contactIdList, topic);
        const request = new wechaty_grpc_1.RoomCreateRequest();
        request.setContactIdsList(contactIdList);
        request.setTopic(topic);
        const response = await util_1.default.promisify(this.grpcClient.roomCreate.bind(this.grpcClient))(request);
        return response.getId();
    }
    async roomQuit(roomId) {
        config_1.log.verbose('PuppetService', 'roomQuit(%s)', roomId);
        const request = new wechaty_grpc_1.RoomQuitRequest();
        request.setId(roomId);
        await util_1.default.promisify(this.grpcClient.roomQuit.bind(this.grpcClient))(request);
    }
    async roomQRCode(roomId) {
        config_1.log.verbose('PuppetService', 'roomQRCode(%s)', roomId);
        const request = new wechaty_grpc_1.RoomQRCodeRequest();
        request.setId(roomId);
        const response = await util_1.default.promisify(this.grpcClient.roomQRCode.bind(this.grpcClient))(request);
        return response.getQrcode();
    }
    async roomMemberList(roomId) {
        config_1.log.verbose('PuppetService', 'roomMemberList(%s)', roomId);
        const request = new wechaty_grpc_1.RoomMemberListRequest();
        request.setId(roomId);
        const response = await util_1.default.promisify(this.grpcClient.roomMemberList.bind(this.grpcClient))(request);
        return response.getMemberIdsList();
    }
    async roomMemberRawPayload(roomId, contactId) {
        config_1.log.verbose('PuppetService', 'roomMemberRawPayload(%s, %s)', roomId, contactId);
        const request = new wechaty_grpc_1.RoomMemberPayloadRequest();
        request.setId(roomId);
        request.setMemberId(contactId);
        const response = await util_1.default.promisify(this.grpcClient.roomMemberPayload.bind(this.grpcClient))(request);
        const payload = {
            avatar: response.getAvatar(),
            id: response.getId(),
            inviterId: response.getInviterId(),
            name: response.getName(),
            roomAlias: response.getRoomAlias(),
        };
        return payload;
    }
    async roomMemberRawPayloadParser(payload) {
        // log.silly('PuppetService', 'roomMemberRawPayloadParser({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    async roomAnnounce(roomId, text) {
        config_1.log.verbose('PuppetService', 'roomAnnounce(%s%s)', roomId, typeof text === 'undefined'
            ? ''
            : `, ${text}`);
        /**
         * Set
         */
        if (text) {
            const textWrapper = new wechaty_grpc_1.StringValue();
            textWrapper.setValue(text);
            const request = new wechaty_grpc_1.RoomAnnounceRequest();
            request.setId(roomId);
            request.setText(textWrapper);
            await util_1.default.promisify(this.grpcClient.roomAnnounce.bind(this.grpcClient))(request);
            return;
        }
        /**
         * Get
         */
        const request = new wechaty_grpc_1.RoomAnnounceRequest();
        request.setId(roomId);
        const response = await util_1.default.promisify(this.grpcClient.roomAnnounce.bind(this.grpcClient))(request);
        const textWrapper = response.getText();
        if (textWrapper) {
            return textWrapper.getValue();
        }
        return '';
    }
    async roomInvitationAccept(roomInvitationId) {
        config_1.log.verbose('PuppetService', 'roomInvitationAccept(%s)', roomInvitationId);
        const request = new wechaty_grpc_1.RoomInvitationAcceptRequest();
        request.setId(roomInvitationId);
        await util_1.default.promisify(this.grpcClient.roomInvitationAccept.bind(this.grpcClient))(request);
    }
    async roomInvitationRawPayload(id) {
        config_1.log.verbose('PuppetService', 'roomInvitationRawPayload(%s)', id);
        const request = new wechaty_grpc_1.RoomInvitationPayloadRequest();
        request.setId(id);
        const response = await util_1.default.promisify(this.grpcClient.roomInvitationPayload.bind(this.grpcClient))(request);
        const payload = {
            avatar: response.getAvatar(),
            id: response.getId(),
            invitation: response.getInvitation(),
            inviterId: response.getInviterId(),
            memberCount: response.getMemberCount(),
            memberIdList: response.getMemberIdsList(),
            receiverId: response.getReceiverId(),
            timestamp: response.getTimestamp(),
            topic: response.getTopic(),
        };
        return payload;
    }
    async roomInvitationRawPayloadParser(payload) {
        // log.silly('PuppetService', 'roomInvitationRawPayloadParser({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    /**
     *
     * Friendship
     *
     */
    async friendshipSearchPhone(phone) {
        config_1.log.verbose('PuppetService', 'friendshipSearchPhone(%s)', phone);
        const request = new wechaty_grpc_1.FriendshipSearchPhoneRequest();
        request.setPhone(phone);
        const response = await util_1.default.promisify(this.grpcClient.friendshipSearchPhone.bind(this.grpcClient))(request);
        const contactIdWrapper = response.getContactId();
        if (contactIdWrapper) {
            return contactIdWrapper.getValue();
        }
        return null;
    }
    async friendshipSearchWeixin(weixin) {
        config_1.log.verbose('PuppetService', 'friendshipSearchWeixin(%s)', weixin);
        const request = new wechaty_grpc_1.FriendshipSearchWeixinRequest();
        request.setWeixin(weixin);
        const response = await util_1.default.promisify(this.grpcClient.friendshipSearchWeixin.bind(this.grpcClient))(request);
        const contactIdWrapper = response.getContactId();
        if (contactIdWrapper) {
            return contactIdWrapper.getValue();
        }
        return null;
    }
    async friendshipRawPayload(id) {
        config_1.log.verbose('PuppetService', 'friendshipRawPayload(%s)', id);
        const request = new wechaty_grpc_1.FriendshipPayloadRequest();
        request.setId(id);
        const response = await util_1.default.promisify(this.grpcClient.friendshipPayload.bind(this.grpcClient))(request);
        const payload = {
            contactId: response.getContactId(),
            hello: response.getHello(),
            id,
            scene: response.getScene(),
            stranger: response.getStranger(),
            ticket: response.getTicket(),
            type: response.getType(),
        }; // FIXME: Huan(202002)
        return payload;
    }
    async friendshipRawPayloadParser(payload) {
        // log.silly('PuppetService', 'friendshipRawPayloadParser({id:%s})', payload.id)
        // passthrough
        return payload;
    }
    async friendshipAdd(contactId, options) {
        config_1.log.verbose('PuppetService', 'friendshipAdd(%s, %s)', contactId, JSON.stringify(options));
        const request = new wechaty_grpc_1.FriendshipAddRequest();
        request.setContactId(contactId);
        // FIXME: for backward compatibility, need to be removed after all puppet has updated.
        if (typeof options === 'string') {
            request.setHello(options);
        }
        else {
            request.setHello(options.hello);
            const contactIdWrapper = new wechaty_grpc_1.StringValue();
            contactIdWrapper.setValue(options.contactId || '');
            const roomIdWrapper = new wechaty_grpc_1.StringValue();
            roomIdWrapper.setValue(options.roomId || '');
            request.setSourceRoomId(roomIdWrapper);
            request.setSourceContactId(contactIdWrapper);
        }
        await util_1.default.promisify(this.grpcClient.friendshipAdd.bind(this.grpcClient))(request);
    }
    async friendshipAccept(friendshipId) {
        config_1.log.verbose('PuppetService', 'friendshipAccept(%s)', friendshipId);
        const request = new wechaty_grpc_1.FriendshipAcceptRequest();
        request.setId(friendshipId);
        await util_1.default.promisify(this.grpcClient.friendshipAccept.bind(this.grpcClient))(request);
    }
    /**
     *
     * Tag
     *
     */
    // add a tag for a Contact. Create it first if it not exist.
    async tagContactAdd(id, contactId) {
        config_1.log.verbose('PuppetService', 'tagContactAdd(%s, %s)', id, contactId);
        const request = new wechaty_grpc_1.TagContactAddRequest();
        request.setId(id);
        request.setContactId(contactId);
        await util_1.default.promisify(this.grpcClient.tagContactAdd.bind(this.grpcClient))(request);
    }
    // remove a tag from the Contact
    async tagContactRemove(id, contactId) {
        config_1.log.verbose('PuppetService', 'tagContactRemove(%s, %s)', id, contactId);
        const request = new wechaty_grpc_1.TagContactRemoveRequest();
        request.setId(id);
        request.setContactId(contactId);
        await util_1.default.promisify(this.grpcClient.tagContactRemove.bind(this.grpcClient))(request);
    }
    // delete a tag from Wechat
    async tagContactDelete(id) {
        config_1.log.verbose('PuppetService', 'tagContactDelete(%s)', id);
        const request = new wechaty_grpc_1.TagContactDeleteRequest();
        request.setId(id);
        await util_1.default.promisify(this.grpcClient.tagContactDelete.bind(this.grpcClient))(request);
    }
    // get tags from a specific Contact
    async tagContactList(contactId) {
        config_1.log.verbose('PuppetService', 'tagContactList(%s)', contactId);
        const request = new wechaty_grpc_1.TagContactListRequest();
        if (typeof contactId !== 'undefined') {
            const contactIdWrapper = new wechaty_grpc_1.StringValue();
            contactIdWrapper.setValue(contactId);
            request.setContactId(contactIdWrapper);
        }
        const response = await util_1.default.promisify(this.grpcClient.tagContactList.bind(this.grpcClient))(request);
        return response.getIdsList();
    }
    async messageSendFileStream(conversationId, file) {
        const request = await mod_1.packConversationIdFileBoxToPb(wechaty_grpc_1.MessageSendFileStreamRequest)(conversationId, file);
        const response = await new Promise((resolve, reject) => {
            if (!this.grpcClient) {
                reject(new Error('Can not send message file since no grpc client.'));
                return;
            }
            const stream = this.grpcClient.messageSendFileStream((err, response) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(response);
                }
            });
            request.pipe(stream);
        });
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
    async messageSendFileNonStream(conversationId, file) {
        const request = new wechaty_grpc_1.MessageSendFileRequest();
        request.setConversationId(conversationId);
        request.setFilebox(JSON.stringify(file));
        const response = await util_1.default.promisify(this.grpcClient.messageSendFile.bind(this.grpcClient))(request);
        const messageIdWrapper = response.getId();
        if (messageIdWrapper) {
            return messageIdWrapper.getValue();
        }
    }
}
exports.PuppetService = PuppetService;
PuppetService.VERSION = config_1.VERSION;
exports.default = PuppetService;
//# sourceMappingURL=puppet-service.js.map