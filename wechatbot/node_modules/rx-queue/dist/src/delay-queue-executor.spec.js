#!/usr/bin/env ts-node
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
// tslint:disable:no-shadowed-variable
import test from 'blue-tape';
import sinon from 'sinon';
import DelayExecutor from './delay-queue-executor';
const DELAY_PERIOD_TIME = 10;
const EXPECTED_VAL1 = 1;
const EXPECTED_VAL2 = 2;
const EXPECTED_VAL3 = 3;
const MEANING_OF_LIFE = 42;
test('DelayQueueExecutor execute once', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const spy = sinon.spy();
    const delay = new DelayExecutor(DELAY_PERIOD_TIME);
    delay
        .execute(() => spy(EXPECTED_VAL1))
        .catch(() => { });
    t.ok(spy.calledOnce, 'should received 1 call immediately');
    t.equal(spy.firstCall.args[0], EXPECTED_VAL1, 'should get EXPECTED_VAL1');
}));
test('DelayQueueExecutor execute thrice', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const spy = sinon.spy();
    const delay = new DelayExecutor(DELAY_PERIOD_TIME);
    delay.execute(() => spy(EXPECTED_VAL1)).catch(() => { });
    delay.execute(() => spy(EXPECTED_VAL2)).catch(() => { });
    delay.execute(() => spy(EXPECTED_VAL3)).catch(() => { });
    t.equal(spy.callCount, 1, 'should call once immediately');
    t.equal(spy.lastCall.args[0], EXPECTED_VAL1, 'should get EXPECTED_VAL1');
    yield new Promise(resolve => setTimeout(resolve, DELAY_PERIOD_TIME + 3));
    t.equal(spy.callCount, 2, 'should call twice after DELAY_PERIOD_TIME');
    t.equal(spy.lastCall.args[0], EXPECTED_VAL2, 'should get EXPECTED_VAL2');
    yield new Promise(resolve => setTimeout(resolve, DELAY_PERIOD_TIME + 3));
    t.equal(spy.callCount, 3, 'should call thrice after 2 x DELAY_PERIOD_TIME');
    t.equal(spy.lastCall.args[0], EXPECTED_VAL3, 'should get EXPECTED_VAL3');
    yield new Promise(resolve => setTimeout(resolve, DELAY_PERIOD_TIME + 3));
    t.equal(spy.callCount, 3, 'should keep third call...');
}));
test('DelayQueueExecutor return Promise', (t) => __awaiter(void 0, void 0, void 0, function* () {
    const delay = new DelayExecutor(0);
    const mol = yield delay.execute(() => MEANING_OF_LIFE);
    t.equal(mol, MEANING_OF_LIFE, 'should get the function return value');
    const p = delay.execute(() => Promise.resolve(MEANING_OF_LIFE));
    t.ok(p instanceof Promise, 'should get the function return value(promise)');
    const value = yield p;
    t.equal(value, MEANING_OF_LIFE, 'should get the function return value by await');
}));
//# sourceMappingURL=delay-queue-executor.spec.js.map