#!/usr/bin/env ts-node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tstest_1 = require("tstest");
const util_1 = __importDefault(require("util"));
const mod_1 = require("../src/mod");
const puppet_server_impl_1 = require("./puppet-server-impl");
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
const SERVER_ENDPOINT = '127.0.0.1:8788';
const ID = 'test-id';
const ALIAS = 'test-alias';
const contactAlias = (call, callback) => {
    const id = call.request.getId();
    let aliasWrapper = call.request.getAlias();
    if (aliasWrapper) {
        /**
         * Set alias, return void
         */
        const alias = aliasWrapper.getValue();
        if (alias !== ALIAS) {
            throw new Error(`alias argument value error: ${alias} not equal to ${ALIAS}`);
        }
        callback(null, new mod_1.ContactAliasResponse());
    }
    else {
        /**
         * Get alias, return alias
         */
        aliasWrapper = new wrappers_pb_1.StringValue();
        aliasWrapper.setValue(id + ALIAS);
        const response = new mod_1.ContactAliasResponse();
        response.setAlias(aliasWrapper);
        callback(null, response);
    }
};
tstest_1.test('use StringValue to support nullable values', async (t) => {
    const puppetServerImplTest = {
        ...puppet_server_impl_1.puppetServerImpl,
        contactAlias,
    };
    const server = new mod_1.grpc.Server();
    server.addService(mod_1.PuppetService, puppetServerImplTest);
    try {
        // FIXME: Huan(202002) if the port has been used by another grpc server, this will still bind with succeed!
        // The result will be one port binded by two grpc server, and they are all working well...
        const port = await util_1.default.promisify(server.bindAsync.bind(server))(SERVER_ENDPOINT, mod_1.grpc.ServerCredentials.createInsecure());
        console.info('port:', port);
        if (port <= 0) {
            t.fail(`server bind to ${SERVER_ENDPOINT} failed, port get ${port}.`);
            return;
        }
    }
    catch (e) {
        /**
          * Run gRPC server failed
          *   https://medium.com/@yuanchaodu/run-grpc-server-failed-289172dbe6e
          *
          * No address added out of total 1 resolved
          *  The above error message means the port is in use.
          */
        t.fail('server bindAsync fail.');
        console.error(e);
    }
    server.start();
    const client = new mod_1.PuppetClient(SERVER_ENDPOINT, mod_1.grpc.credentials.createInsecure());
    const contactAliasPromise = util_1.default.promisify(client.contactAlias.bind(client));
    /**
     * Get alias
     */
    {
        const request = new mod_1.ContactAliasRequest();
        request.setId(ID);
        const response = await contactAliasPromise(request);
        const aliasWrapper = response.getAlias();
        t.ok(aliasWrapper, 'Should return an aliasWrapper');
        if (aliasWrapper) {
            const alias = aliasWrapper.getValue();
            t.equal(alias, ID + ALIAS, 'should get the right alias value');
        }
        else {
            t.fail('can not get alias value');
        }
    }
    /**
     * Set alias
     */
    {
        const aliasWrapper = new wrappers_pb_1.StringValue();
        aliasWrapper.setValue(ALIAS);
        const request = new mod_1.ContactAliasRequest();
        request.setId(ID);
        request.setAlias(aliasWrapper);
        const response = await contactAliasPromise(request);
        const nullAliasWrapper = response.getAlias();
        t.notOk(nullAliasWrapper, 'should return undefined for null value');
    }
    await new Promise(resolve => server.tryShutdown(resolve));
    setImmediate(() => server.forceShutdown());
});
//# sourceMappingURL=nullable.spec.js.map