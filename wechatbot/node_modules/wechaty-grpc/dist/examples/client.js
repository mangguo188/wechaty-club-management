"use strict";
// tslint:disable:no-console
// tslint:disable:max-line-length
// tslint:disable:no-shadowed-variable
// tslint:disable:callable-types
Object.defineProperty(exports, "__esModule", { value: true });
exports.testStream = exports.testDing = exports.testAlias = void 0;
// import { Metadata } from '@grpc/grpc-js'
const wrappers_pb_1 = require("google-protobuf/google/protobuf/wrappers_pb");
// import { CallMetadataGenerator } from '@grpc/grpc-js/build/src/call-credentials'
const mod_1 = require("../src/mod");
const promisify_1 = require("./promisify");
async function testAlias(client) {
    const request = new mod_1.ContactAliasRequest();
    const contactAlias = promisify_1.promisify(client.contactAlias.bind(client));
    {
        const response = await contactAlias(request);
        const aliasWrapper = response.getAlias();
        let alias;
        if (aliasWrapper) {
            alias = aliasWrapper.getValue();
        }
        console.info('returned alias:', alias);
    }
    console.info('##############');
    {
        const aliasWrapper = new wrappers_pb_1.StringValue();
        aliasWrapper.setValue('test alias');
        request.setAlias(aliasWrapper);
        const response = await contactAlias(request);
        const returnAliasWrapper = response.getAlias();
        if (returnAliasWrapper) {
            console.info('returned alias:', returnAliasWrapper);
            throw new Error('should not has alas return');
        }
        console.info('ok');
    }
}
exports.testAlias = testAlias;
async function testDing(client) {
    const ding = promisify_1.promisify(client.ding.bind(client));
    const dingRequest = new mod_1.DingRequest();
    dingRequest.setData('dingdong');
    try {
        // const metadata = new Metadata()
        // metadata.set('grpc.default_authority', 'puppet_token')
        await ding(dingRequest /* metadata */);
    }
    catch (e) {
        console.error(e);
    }
}
exports.testDing = testDing;
function testStream(client) {
    // event(request: wechaty_puppet_event_pb.EventRequest, options?: Partial<grpc.CallOptions>): grpc.ClientReadableStream<wechaty_puppet_event_pb.EventRequest>;
    const eventStream = client.event(new mod_1.EventRequest());
    eventStream
        .on('data', (chunk) => {
        // console.info('EventType:', EventType)
        // console.info('type:', chunk.getType(), EventType[chunk.getType()], EventType[23])
        console.info('payload:', chunk.getPayload());
        // console.info('eventStream.on(data):', chunk)
    })
        .on('end', () => {
        console.info('eventStream.on(end)');
    });
}
exports.testStream = testStream;
async function main() {
    // const metadata = new grpc.Metadata()
    // metadata.add('authorization', 'Bearer ' + 'access_token')
    // const generateMetadata: CallMetadataGenerator = (_params, callback) => { console.info('generateMetadata'); callback(null, metadata) }
    // const authCred = grpc.credentials.createFromMetadataGenerator(generateMetadata)
    // const sslCred = grpc.credentials.createSsl()
    // const creds = grpc.credentials.combineChannelCredentials(
    //   sslCred,
    //   authCred,
    // )
    const creds = mod_1.grpc.credentials.createInsecure();
    const client = new mod_1.PuppetClient('localhost:8788', creds, {
        'grpc.default_authority': 'puppet_token',
    });
    testStream(client);
    setInterval(() => testDing(client), 1000);
    // await testAlias(client)
    return 0;
}
main()
    // .then(process.exit)
    .catch(e => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=client.js.map